# 服务端总体设计

## 初稿：多线程设计

服务端要干的事情

- 用户突发请求——消息队列

- 从等待区取出车插入，有空插入

- 充电桩计时还是总体计时——时间段计费，

  ```java
  //每个chargeStation有一个当前每秒计费，一到一个时间点更换这个每秒计费
  ```

  

发起一次充电请求后，服务器就存着这个car，直到充电完成或取消充电





充电区：一个线程

- 循环
  - 遍历所有充电桩的第一个充电（没有就不计费），完成一次计费和充电，要改动的存在car里。并且每个充电桩自己的剩余充电时间也要改
  - 处理要增加删除的list的car，注意只是把car加入或移出队列，没有删除car或新建car。当处理完后，记得修改car的状态，可以加个锁



等待区：一个线程

- 循环
  - 两个队列头遍历所有充电桩的剩余充电时间，选最小的，给充电桩的发个消息。可以加个锁，充电区有空闲的时候就会开锁
  - 处理要增删的等待的car



处理突发：一个或多个线程

- 处理消息队列，增删改查，涉及充电区的就给充电区发个消息就行
- 如果不用消息队列，那就控制器之前接管，那控制器会出现多个线程或协程吗



## 新版：服务端使用单线程加消息队列

- [ ] ```java
  消息队列，叫做MQ;
  public void run() {
      while(MQ is Not Empty) {
          Message msg = MQ.getHead;
          switch msg:
          case1:;
          schedule/charging
          case2：;
          case3;
          default:         
      }
  }
  ```



### 消息种类（所有消息都是服务端插入）

- 提交进入等候区的请求
  - 如果等候区没办法加入，返回false。
  - 如果加入等候区成功，尝试调度一次，并返回True。这个True代表加入等候区成功，不代表其他事情。

- 暗示当前充电桩存在空位的消息：
  - 有辆车完成充电。充电完成的消息。这里在发出消息之前顺手调用一下 `UpdateStationState()`更新一下充电桩的状态信息
  - 取消充电（不管是在等候区等候，还是正在充电桩充电或者等候，都可以取消充电）。无所谓，反正都进行一次调度，开销忽略不计。

- 充电中途请求查看详单：前端发出请求，控制器通知服务器， 服务器知道之后，往消息队列里插一个详单的消息。至于客户端那边到底要详单的什么东西，服务端不关心。一股脑全部返回过去就行了。
  - 查的时候，计算一下、更新一下再返回。


来自客户端的请求所导致的消息：

- 用户注册：返回一个注册成功与否以及失败原因给控制器
- 用户登录：返回一个登录成功与否的消息。
- 修改充电模式：告诉服务端要修改哪辆车的。直接把模式往反向改就行了。
  - 都只允许在等候区修改
  - 所以会返回就一个布尔值，失败false。改不了就肯定在充电区。

- 修改本次充电电量：也要告诉修改哪辆车的（车的主键）
  - 只允许在等候区修改。排队号不变
  - 返回一个布尔值，改失败说明现在在充电桩那里，不能改。

- 查看本车排队号码：也要告诉我是哪辆车。
- 查看本充电模式下前车等待数量：告诉我是哪辆车
- 结束充电（取消充电？）



来自管理员客户端的请求所导致的消息：

- 开关充电桩：告诉我充电桩编号
- 查看**所有**充电桩状态
- 查看各充电桩等候服务的车辆信息
- 报表展示

充电桩故障：发一个故障消息。我的期望是：告诉我是第几个充电桩故障了。

充电桩故障恢复：发一个故障恢复的消息。我的期望：告诉我第几个好了，那之前坏的就是第几个















# 废案

## 从起点终点得到总计费

```
while(对于所有时间段)
	if( !( 充电终点<时间段终点 || 充电起点>时间段终点 ) )
		总价 += 单位计费*( max{时间段终点，充电终点} - min{时间段起点,充电起点} );
```

